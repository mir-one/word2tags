# Word2tags - русский грамматический словарь - лексикон с морфологическими тегами

В составе пакета есть 2 класса: word2tags и Flexer, в которых сосредоточены базовые операций с русской морфологией. word2tags разрабатывается как поставщик грамматических признаков слов (фич) для алгоритмов машинного обучения. Flexer содержит функционал для генеративных языковых моделей.

Для использования любого из классов нужно создать его экземпляр и затем вызвать у объекта метод load(), чтобы загрузилась словарная база.


## Класс Word2tags

Данный класс реализует единственную операцию - для заданного слова выдывать все варианты наборов морфологического анализа в виде списков тегов. К примеру, для слова *кошки* с помощью этого словаря можно определить, что это существительное либо в форме именительного падежа множественного числа, либо в форме родительного падежа единственного числа.

Для основных частей речи (существительные, прилагательные, глаголы) словарь содержит несколько миллионов слов, обеспечивая распознавание большинства лексики в текстах. Кроме того, для многих новых (out-of-vocabulary) слов пакет обеспечивает распознавание, даже если точно такого слова нет в словаре.

Морфологическая информация при сборке пакета берется из текущей версии [Русского Грамматического Словаря](https://github.com/mir-one/GrammarEngine), содержащего грамматическую информацию о более чем 4,3 миллионов словарных форм.

Для многих слов в русском языке набор грамматических тегов определяется неоднозначно, как в вышеупомянутом примере с "кошки". В контексте предложения обычно можно снять эту неоднозначность, учитывая правила согласования и синтаксис русского языка. Используйте [part-of-speech tag](https://github.com/mir-one/postag) или [парсер](https://github.com/mir-one/GrammarEngine/tree/master/src/demo/ai/solarix/argon/ParseText/Parser) для такой работы.


## Класс Flexer

Основаная функция этого класса - подбор форм слов по лемме и набору грамматических признаков. Данная операция нужна для построения генеративных моделей, например для аугментации NLP датасетов. К примеру, для леммы "кошка" и набора тегов {падеж=твор, число=мн} мы получим "кошками". Далее есть пример вызова соответствующего метода.

## Совместимость

Пакет работает в питоне вер.3 под Windows и Linux, не требуя каких-либо внешних зависимостей.

## Установка

Наберите в консоли, возможно потребуется sudo:

```
pip3 install git+https://github.com/mir-one/word2tags
```

## Ошибка "sqlite3.DatabaseError: file is not a database"

К сожалению, после установки из репозитория часто возникает ошибка "sqlite3.DatabaseError: file is not a database" при работе со словарем. Это происходит из-за неверной выгрузки файла [word2tags.db](https://github.com/mir-one/word2tags/blob/master/word2tags/word2tags.db). Для исправления заберите копию этого файла [отсюда](https://drive.google.com/file/d/1V8-L1vMQoPjkfcddj0rWU4PPQjhBXIZy/view?usp=sharing) и скопируйте его в склонированный локально репозиторий. После этого установите пакет из локальной копии командой 

```
pip3 install .
```


## API

В текущей версии пакет требует, чтобы распознаваемые слова были заранее приведены к нижнему регистру.

Словарь представлен экземпляром класса word2tags.word2tags. Словарь нужно загрузить с диска перед использованием вызовом load().

Для распознавания одного слова нужно вызвать индексатор - см. пример далее.


## Примеры использования word2tags

```
import word2tags


# Создаем экземпляр словаря и загружаем его
word2tags = word2tags.word2tags()
word2tags.load()

# Получим теги для нескольких слов
for word in u'кошки рой для'.split():
	for i, tagset in enumerate(word2tags[word]):
		print(u'{}[{}] => {}'.format(word, i, tagset))
```

Результат:

```
кошки[0] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ИМ РОД=ЖЕН ЧИСЛО=МН
кошки[1] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=РОД РОД=ЖЕН ЧИСЛО=ЕД
рой[0] => ГЛАГОЛ ВИД=НЕСОВЕРШ ЛИЦО=2 НАКЛОНЕНИЕ=ПОБУД ПАДЕЖ=ВИН ПАДЕЖ=ДАТ ПАДЕЖ=ТВОР ЧИСЛО=ЕД
рой[1] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ВИН РОД=МУЖ ЧИСЛО=ЕД
рой[2] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ИМ РОД=МУЖ ЧИСЛО=ЕД
для[0] => ДЕЕПРИЧАСТИЕ ВИД=НЕСОВЕРШ ПАДЕЖ=ВИН
для[1] => ПРЕДЛОГ ПАДЕЖ=РОД
```

Возвращаемая индексатором класса word2tags.word2tags строка содержит набор тегов, разделенных пробелом. Первый элемент - наименование части речи, далее идут теги в формате ТЕГ=ЗНАЧЕНИЕ.

Для несловарных данных распознавание будет давать множество вариантов. Например:

```
for word in u'ккошки'.split():
	for i, tagset in enumerate(word2tags[word]):
		print(u'{}[{}] => {}'.format(word, i, tagset))
```

дает результаты:

```
ккошки[0] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ВИН РОД=СР ЧИСЛО=МН
ккошки[1] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=РОД РОД=МУЖ ЧИСЛО=ЕД
ккошки[2] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ИМ РОД=МУЖ ЧИСЛО=МН
ккошки[3] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ВИН РОД=ЖЕН ЧИСЛО=МН
ккошки[4] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ИМ РОД=ЖЕН ЧИСЛО=МН
ккошки[5] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=РОД РОД=ЖЕН ЧИСЛО=ЕД
ккошки[6] => СУЩЕСТВИТЕЛЬНОЕ ПАДЕЖ=ИМ РОД=СР ЧИСЛО=МН
```


## Пример использования Flexer

```
import word2tags

flexer = word2tags.Flexer()
flexer.load()

forms = flexer.find_forms_by_tags(u'кошка', [(u'ПАДЕЖ', u'ТВОР'), (u'ЧИСЛО', u'МН')])
print(list(forms))
```

дает результат:

```
['кошками']
```
